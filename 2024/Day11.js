// Puzzle for Day 11: https://adventofcode.com/2024/day/11

/**
 * Main Runner
 * @param {string[]} fileContents The file contents in an array of strings for each line
 * @returns {{part1: *, part2: *}} The puzzle results
 */
export const run = async (fileContents) => {
  let data = fileContents[0].split(" ").map((val) => parseInt(val));
  let result1 = runSim(data, 25);
  let result2 = runSim(data, 75);
  return { part1: result1, part2: result2 };
};

/**
 * Solution for Parts 1 and 2
 * @param {number[]} data Input data array
 * @param {number} iterations Number of time to run the simulation
 * @returns {number} The total count of numbers in the result
 */
const runSim = (data, iterations) => {
  // Create a map for storing the unique numbers and
  // how many times they appear in the array. The size
  // of the numbers it wil generate make storing this
  // as an array of the numbers impossible. Since order
  // doesn't matter Map's are ideal for this.
  let nums = new Map();
  // Store the array values into the map with the count
  // of the number of time they appear.
  for (let num of data) {
    // If new add the value with a count of one
    if (!nums.has(num)) nums.set(num, 1);
    // Otherwise increment the existing count by one
    else nums.set(num, nums.get(num) + 1);
  }

  // Continue the process for the specified number of times.
  for (let i = 0; i < iterations; i++) {
    // Create a new Map for the results of this iteration
    let newNums = new Map();
    // Compute the results for each unique number in the existing map
    nums.forEach((count, num) => {
      // Store an array of the results for processing this number
      let newNumsArray = [];
      // If the number is 0 add a 1 to the new numbers
      if (num === 0) {
        newNumsArray.push(1);
      }
      // Otherwise find the number of digits
      else {
        // Get the number of digits a number has. This is from what was done on Day 7
        let digitCount = Math.floor(Math.log10(num)) + 1;
        // If even number of digits
        if (digitCount % 2 == 0) {
          // Create a divisor for this number by getting 10^(half the number of digits)
          let digitDivider = Math.pow(10, digitCount / 2);
          // Get the left half by dividing and dropping the remainder
          newNumsArray.push(Math.floor(num / digitDivider));
          // Get the right half by dividing and only keeping the remainder
          newNumsArray.push(num % digitDivider);
        } else {
          // If nothing else applies multiply the value by 2024
          newNumsArray.push(num * 2024);
        }
      }

      // For each of the new numbers generated by the rules for
      // this number add the count to the new numbers Map
      for (let newNum of newNumsArray) {
        // If not in the Map add it with the count of the current number
        if (!newNums.has(newNum)) newNums.set(newNum, count);
        // Otherwise add the count to the Map with the current count of this number
        else newNums.set(newNum, newNums.get(newNum) + count);
      }
    });
    // Assign the new numbers Map to the numbers Map after all numbers
    // have been processed.
    nums = newNums;
  }

  // Get the total count of all numbers
  let totalNums = 0;
  // Iterate through the numbers Map and total all of the counts
  nums.forEach((count) => (totalNums += count));
  return totalNums;
};
